# Journey Backend — Full Build & Deployment Plan

> **Target stack:** TypeScript · NestJS · Prisma · PostgreSQL · Railway  
> **iOS client base URL:** `https://yourjourney.it.com`  
> **Backend lives on:** the `backend` git branch (currently empty)

---

## 1. Problem Statement

The iOS app is fully wired to a backend that does not exist yet. Every service call (`/chat/sendMessage`, `/journal/generate`, `/auth/*`, `/calendar/summary`, `/days/:dayKey`) returns a stub or is commented out on the client. This plan defines every file, module, migration, and deployment step needed to make the real backend live on Railway.

---

## 2. Repository Layout

The backend is a standalone NestJS project that lives at the root of the `backend` branch. It is **not** a sub-folder inside the iOS project.

```
journey-backend/
├── prisma/
│   ├── schema.prisma
│   └── migrations/          # auto-generated by Prisma
├── src/
│   ├── main.ts               # bootstrap, reads PORT from env
│   ├── app.module.ts         # root module
│   ├── db/
│   │   ├── db.module.ts      # PrismaService provider
│   │   └── prisma.service.ts
│   ├── ai/
│   │   ├── ai.module.ts
│   │   └── ai.service.ts     # ONLY place that calls OpenAI (or any AI provider)
│   ├── auth/
│   │   ├── auth.module.ts
│   │   ├── auth.controller.ts
│   │   ├── auth.service.ts
│   │   ├── jwt.strategy.ts
│   │   └── dto/
│   │       ├── register.dto.ts
│   │       ├── login.dto.ts
│   │       └── refresh.dto.ts
│   ├── chat/
│   │   ├── chat.module.ts
│   │   ├── chat.controller.ts
│   │   ├── chat.service.ts
│   │   ├── chat.repository.ts
│   │   └── dto/
│   │       └── send-message.dto.ts
│   ├── journal/
│   │   ├── journal.module.ts
│   │   ├── journal.controller.ts
│   │   ├── journal.service.ts
│   │   ├── journal.repository.ts
│   │   └── dto/
│   │       └── generate-journal.dto.ts
│   ├── calendar/
│   │   ├── calendar.module.ts
│   │   ├── calendar.controller.ts
│   │   └── calendar.service.ts
│   └── days/
│       ├── days.module.ts
│       ├── days.controller.ts
│       └── days.service.ts
├── test/
│   ├── chat.service.spec.ts
│   ├── journal.service.spec.ts
│   ├── daykey.util.spec.ts
│   └── app.e2e-spec.ts
├── .env.example
├── .gitignore
├── nest-cli.json
├── package.json
├── tsconfig.json
└── railway.toml              # Railway config
```

---

## 3. Environment Variables

The app must boot with **only** these four variables (provided by Railway):

| Variable | Description |
|---|---|
| `DATABASE_URL` | PostgreSQL connection string (Railway-provisioned) |
| `PORT` | HTTP port (Railway injects this automatically) |
| `AI_PROVIDER_KEY` | OpenAI (or compatible) API key |
| `NODE_ENV` | `production` in prod, `development` locally |

Optional (needed when auth is enabled):

| Variable | Description |
|---|---|
| `JWT_ACCESS_SECRET` | Secret for signing access tokens |
| `JWT_REFRESH_SECRET` | Secret for signing refresh tokens |

Never hardcode any of these. Never commit `.env` to source control.

---

## 4. Prisma Schema

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String         @id @default(uuid())
  email        String         @unique
  passwordHash String
  createdAt    DateTime       @default(now())
  messages     Message[]
  journalEntries JournalEntry[]
  refreshTokens  RefreshToken[]
}

model Message {
  id        String   @id @default(uuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  dayKey    String
  role      String   // "user" | "assistant" | "system"
  text      String
  timestamp DateTime @default(now())

  @@index([dayKey])
  @@index([userId, dayKey])
}

model JournalEntry {
  id        String   @id @default(uuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  dayKey    String
  text      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, dayKey])   // one entry per user per day
  @@index([dayKey])
  @@index([userId, dayKey])
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}
```

Key rules enforced by schema:
- `@@unique([userId, dayKey])` on `JournalEntry` prevents duplicate entries per day.
- `@@index([userId, dayKey])` on both tables supports all bounded-window queries.
- `userId` is nullable to support single-user MVP mode without breaking multi-user readiness.

---

## 5. API Contract (matches iOS client exactly)

### Auth (iOS `AuthService` already calls these)

| Method | Path | Auth | Description |
|--------|------|------|-------------|
| POST | `/auth/register` | public | Create account, return `{ user, tokens }` |
| POST | `/auth/login` | public | Return `{ user, tokens }` |
| POST | `/auth/logout` | public | Invalidate refresh token |
| POST | `/auth/refresh` | public | Exchange refresh token for new pair |

**Auth response shape** (must match `handleAuthResponse` in `AuthService.swift`):
```json
{
  "user":   { "id": "uuid", "email": "..." },
  "tokens": { "accessToken": "...", "refreshToken": "..." }
}
```

### Chat

| Method | Path | Auth | Description |
|--------|------|------|-------------|
| POST | `/chat/sendMessage` | Bearer | Persist user message, call AI, return assistant reply |

**Request body** (from `SendMessageRequest` in `ChatService.swift`):
```json
{
  "dayKey":          "2026-02-25",
  "userText":        "How are you?",
  "clientMessageId": "optional-uuid"
}
```

**Response** (consumed by `ChatViewModel`):
```json
{
  "assistantMessage": {
    "id": "uuid", "dayKey": "2026-02-25",
    "role": "assistant", "text": "...", "timestamp": "ISO8601"
  }
}
```

Behavior:
1. Validate `dayKey` matches `/^\d{4}-\d{2}-\d{2}$/`.
2. Persist incoming user message immediately (never lose it).
3. Load prior messages for that day (max 40 messages as context window).
4. Build prompt and call `AiService.chat()`.
5. Persist assistant reply.
6. Return assistant reply.
7. Idempotency: if `clientMessageId` already exists for `(userId, dayKey)`, return cached assistant reply.

### Journal

| Method | Path | Auth | Description |
|--------|------|------|-------------|
| POST | `/journal/generate` | Bearer | Generate + upsert journal entry for a day |

**Request** (from `GenerateJournalRequest`):
```json
{ "dayKey": "2026-02-25" }
```

**Response** (consumed by `DayDetailViewModel`):
```json
{
  "journalEntry": {
    "id": "uuid", "dayKey": "2026-02-25",
    "text": "...", "createdAt": "ISO8601", "updatedAt": "ISO8601"
  }
}
```

### Calendar

| Method | Path | Auth | Description |
|--------|------|------|-------------|
| GET | `/calendar/summary?month=YYYY-MM` | Bearer | Return activity indicators for every day in a month |

**Response** (consumed by `CalendarViewModel`):
```json
{
  "days": [
    { "dayKey": "2026-02-01", "hasConversation": true,  "hasJournalEntry": false },
    { "dayKey": "2026-02-02", "hasConversation": false, "hasJournalEntry": true  }
  ]
}
```

### Days

| Method | Path | Auth | Description |
|--------|------|------|-------------|
| GET | `/days/:dayKey` | Bearer | Return full conversation + journal for a day |

**Response** (consumed by `DayDetailViewModel`):
```json
{
  "conversation":  { "dayKey": "...", "messages": [...] },
  "journalEntry":  { ... } | null
}
```

### Legacy History (used by older `AuthService` calls — must not break)

| Method | Path | Auth | Description |
|--------|------|------|-------------|
| GET | `/history/:date` | Bearer | Return `{ compressed_history }` |
| POST | `/history` | Bearer | Persist compressed history + summary |
| GET | `/summaries/:date` | Bearer | Return `{ summaries: string[] }` |

> These three legacy endpoints exist in the iOS `AuthService`. Stub them returning empty/null data for MVP so the client doesn't crash. Full implementation is post-MVP.

---

## 6. Module Breakdown

### `DbModule` / `PrismaService`
- Wraps `PrismaClient`, exported globally.
- Calls `$connect()` on `onModuleInit`, `$disconnect()` on `onModuleDestroy`.
- Used by every repository.

### `AiModule` / `AiService`
- **Only module that may call an AI provider.**
- Exposes `chat(messages: {role, content}[]): Promise<string>` and `summarise(messages: string[]): Promise<string>`.
- Reads `AI_PROVIDER_KEY` from `ConfigService`.
- Uses OpenAI SDK (`openai` npm package); provider-agnostic interface.
- Truncates prompt to stay within token limit (safe max: 12,000 tokens ≈ 40 messages).
- Retries once with exponential back-off on 429/500.

### `AuthModule` / `AuthService`
- `register` — hash password with `bcrypt`, create `User`, issue JWT pair.
- `login` — verify password, issue JWT pair.
- `logout` — delete `RefreshToken` record.
- `refresh` — validate refresh token, rotate pair.
- `JwtStrategy` — validates `Authorization: Bearer` header, populates `req.user`.
- Access token TTL: 15 minutes. Refresh token TTL: 30 days.
- For MVP single-user mode: `userId` can be hardcoded/skipped; all endpoints still accept the header for future-proofing.

### `ChatModule` / `ChatService` / `ChatRepository`
- `ChatRepository` — thin Prisma wrapper: `createMessage`, `getMessagesByDayKey`, `findByClientMessageId`.
- `ChatService` — orchestrates: persist user msg → load context → call `AiService.chat()` → persist + return assistant msg.
- `ChatController` — validates DTO, extracts `userId` from JWT (or null for MVP), delegates to service.

### `JournalModule` / `JournalService` / `JournalRepository`
- `JournalRepository` — `upsertEntry(userId, dayKey, text)`, `findByDayKey(userId, dayKey)`.
- `JournalService` — loads messages for day → calls `AiService.summarise()` → upserts entry.
- `JournalController` — validates DTO, delegates.

### `CalendarModule` / `CalendarService`
- `CalendarService` — queries `Message` and `JournalEntry` tables for the given month range, returns `{ dayKey, hasConversation, hasJournalEntry }[]`.
- Uses a single aggregation query (not N+1).

### `DaysModule` / `DaysService`
- Composes `ChatRepository` and `JournalRepository` to return a combined day snapshot.

---

## 7. AI Prompt Design

### Chat system prompt
```
You are Journey — a calm, reflective AI companion. Your role is to help the user
process their thoughts and feelings through gentle, open-ended conversation.
Be warm, brief, and curious. Never give advice unless asked. Never judge.
Always respond in 1–3 short sentences.
```

### Journal generation prompt
```
The following are excerpts from a personal journal conversation.
Write a single thoughtful, reflective journal entry in first person (2–4 sentences)
that captures the emotional essence of the day. Use a calm, personal tone.
Do not invent events not mentioned in the conversation.

Conversation:
{{messages}}
```

---

## 8. Error Handling

- All DTO validation via `class-validator` + `ValidationPipe` (global).
- Custom `DayKeyPipe` validates format `/^\d{4}-\d{2}-\d{2}$/` before any handler runs.
- AI call failures: always persist user message first; if AI fails, return `503` with structured error — **never lose the user message**.
- Database errors: let NestJS exception filter catch `PrismaClientKnownRequestError`; translate `P2002` (unique violation) to `409 Conflict`.
- Structured error response shape:
  ```json
  { "statusCode": 400, "message": "dayKey must match YYYY-MM-DD", "error": "Bad Request" }
  ```

---

## 9. Testing Strategy

### Unit tests (`*.spec.ts`)
- `DayKeyPipe` — valid/invalid format inputs.
- `ChatService` — message ordering, idempotency check, AI fallback on error.
- `JournalService` — upsert creates new / updates existing; returns existing if AI unavailable.
- `AiService` — mock OpenAI client; verify prompt truncation logic.

### Integration tests (`app.e2e-spec.ts`)
- Spin up real Postgres via `@testcontainers/postgresql`.
- `POST /auth/register` → `POST /auth/login` → `POST /chat/sendMessage` → `GET /days/:dayKey`.
- Verify journal upsert uniqueness constraint.

---

## 10. Railway Deployment

### `railway.toml`
```toml
[build]
builder = "NIXPACKS"

[deploy]
startCommand = "npm run start:prod"
releaseCommand = "npx prisma migrate deploy"
healthcheckPath = "/health"
healthcheckTimeout = 30
restartPolicyType = "ON_FAILURE"
restartPolicyMaxRetries = 3
```

### `package.json` scripts
```json
{
  "scripts": {
    "build":       "nest build",
    "start:prod":  "node dist/main",
    "start:dev":   "nest start --watch",
    "migrate:dev": "prisma migrate dev",
    "db:generate": "prisma generate"
  }
}
```

### Health endpoint
`GET /health` returns `{ "status": "ok" }` — no auth required. Used by Railway's health check.

### Deployment flow
1. Push to `backend` branch triggers Railway rebuild.
2. Nixpacks detects Node, installs deps, runs `nest build`.
3. Railway runs `npx prisma migrate deploy` as release step (applies pending migrations against live Postgres).
4. Railway starts `node dist/main` — reads `PORT` from env.
5. Health check passes → traffic routed.

### Railway environment variables to set
In the Railway dashboard, set:
- `DATABASE_URL` — auto-filled by Railway Postgres plugin
- `PORT` — auto-filled by Railway
- `AI_PROVIDER_KEY` — set manually
- `NODE_ENV=production`
- `JWT_ACCESS_SECRET` — generate with `openssl rand -hex 32`
- `JWT_REFRESH_SECRET` — generate with `openssl rand -hex 32`

---

## 11. iOS Client Wiring (what changes after backend is live)

In `ChatService.swift`, uncomment the real API calls and remove the stub:
```swift
// sendMessage: POST /chat/sendMessage
// generateJournalEntry: POST /journal/generate
```

In `CalendarViewModel`, wire `CalendarService` to call `GET /calendar/summary?month=YYYY-MM` instead of querying local repositories directly.

In `DayDetailViewModel`, wire `GET /days/:dayKey`.

`APIClient.baseURL` is already set to `https://yourjourney.it.com` — no change needed once the Railway custom domain is pointed there.

---

## 12. Implementation Phases

### Phase 1 — Scaffold & Infrastructure
- Init NestJS project on `backend` branch.
- Set up `tsconfig.json`, `nest-cli.json`, `package.json`.
- Add `DbModule` with `PrismaService`.
- Write `prisma/schema.prisma` (Message, JournalEntry, User, RefreshToken).
- Run first migration: `prisma migrate dev --name init`.
- Add `/health` endpoint.
- Configure `ValidationPipe` globally.
- Add `.gitignore`, `.env.example`.
- Add `railway.toml`.

### Phase 2 — Auth
- Implement `AuthModule` with `register`, `login`, `logout`, `refresh`.
- `bcrypt` password hashing.
- JWT access + refresh tokens.
- `JwtStrategy` for `@UseGuards(AuthGuard('jwt'))`.
- Stub the three legacy `/history` and `/summaries` endpoints (return empty/null).
- Unit tests for auth service.

### Phase 3 — Chat
- Implement `AiModule` / `AiService` (OpenAI chat completion).
- Implement `ChatRepository` and `ChatService`.
- `POST /chat/sendMessage` with idempotency.
- Unit tests for `ChatService` and `AiService`.

### Phase 4 — Journal & Calendar
- Implement `JournalRepository` and `JournalService`.
- `POST /journal/generate`.
- `GET /calendar/summary?month=YYYY-MM`.
- `GET /days/:dayKey`.
- Unit tests for journal upsert uniqueness.

### Phase 5 — Integration Tests & Hardening
- E2E tests with Testcontainers.
- Error handling audit (AI failure path, validation edge cases).
- Token rotation test.

### Phase 6 — Deploy to Railway
- Push `backend` branch to GitHub.
- Connect Railway to the repo, select `backend` branch.
- Add Railway Postgres plugin → `DATABASE_URL` auto-wired.
- Set remaining env vars in Railway dashboard.
- Verify health check, run smoke test against all endpoints.
- Point custom domain `yourjourney.it.com` to Railway service.

---

## 13. Key Constraints (non-negotiable)

- AI must only be called inside `AiService`. No other service, controller, or repository may import an AI SDK.
- User messages must be persisted before any AI call is attempted. A failed AI call must never result in a lost user message.
- Every schema change requires a Prisma migration. No ad-hoc `db push` in production.
- `userId` is nullable throughout MVP but every query must be structured to accept it, so multi-user works without a schema change.
- No workers, queues, or cron jobs. All processing is request-bound for MVP.
- Logs go to stdout/stderr only. No file-based logging.
